#ifndef SCRIPPARSER_H_
#define SCRIPPARSER_H_

// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

#include <cstdlib>
#include <cassert>
#include <vector>

namespace Scrip {

enum Token {
    token_eof,
    token_error,
    token_brace_close,
    token_brace_open,
    token_comma,
    token_dollar,
    token_ident,
    token_kwd_break,
    token_kwd_continue,
    token_kwd_else,
    token_kwd_if,
    token_kwd_return,
    token_kwd_while,
    token_number,
    token_op_add,
    token_op_assign,
    token_op_differ,
    token_op_div,
    token_op_equal,
    token_op_greater,
    token_op_greatereq,
    token_op_less,
    token_op_lesseq,
    token_op_mul,
    token_op_not,
    token_op_sub,
    token_paren_close,
    token_paren_open,
    token_semicolon,
};

inline const char* token_label(Token t) {
    static const char* labels[] = {
        "token_eof",
        "token_error",
        "token_brace_close",
        "token_brace_open",
        "token_comma",
        "token_dollar",
        "token_ident",
        "token_kwd_break",
        "token_kwd_continue",
        "token_kwd_else",
        "token_kwd_if",
        "token_kwd_return",
        "token_kwd_while",
        "token_number",
        "token_op_add",
        "token_op_assign",
        "token_op_differ",
        "token_op_div",
        "token_op_equal",
        "token_op_greater",
        "token_op_greatereq",
        "token_op_less",
        "token_op_lesseq",
        "token_op_mul",
        "token_op_not",
        "token_op_sub",
        "token_paren_close",
        "token_paren_open",
        "token_semicolon",
    };
    return labels[t];
}

template <class T, unsigned int StackSize>
class Stack {
public:
    Stack() { gap_ = 0; }

    void rollback_tmp() {
        gap_ = stack_.size();
        tmp_.clear();
    }

    void commit_tmp() {
        // may throw
        stack_.reserve(gap_ + tmp_.size());
	   
        // expect not to throw
        stack_.erase(stack_.begin()+ gap_, stack_.end());
        stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());
        tmp_.clear();
    }
    bool push(const T& f) {
        if (StackSize != 0 &&
            int(StackSize) <= int(stack_.size() + tmp_.size())) {
            return false;
        }
        tmp_.push_back(f);
        return true;
    }
	   
    void pop(size_t n) {
        if (tmp_.size() < n) {
            n -= tmp_.size();
            tmp_.clear();
            gap_ -= n;
        } else {
            tmp_.erase(tmp_.end() - n, tmp_.end());
        }
    }

    T& top() {
        assert(0 < depth());
        if (!tmp_.empty()) {
            return tmp_.back();
        } else {
            return stack_[gap_ - 1];
        }
    }
	   
    const T& get_arg(size_t base, size_t index) {
        size_t n = tmp_.size();
        if (base - index <= n) {
            return tmp_[n - (base - index)];
        } else {
            return stack_[gap_ - (base - n) + index];
        }
    }
	   
    void clear() {
        stack_.clear();
        tmp_.clear();
        gap_ = 0; 
    }
	   
    bool empty() const {
        if (!tmp_.empty()) {
            return false;
        } else {
            return gap_ == 0;
        }
    }
	   
    size_t depth() const {
        return gap_ + tmp_.size();
    }
	   
    T& nth(size_t index) {
        if (gap_ <= index) {
            return tmp_[index - gap_];
        } else {
            return stack_[index];
        }
    }

    void swap_top_and_second() {
        int d = depth();
        assert(2 <= d);
        T x = nth(d - 1);
        nth(d - 1) = nth(d - 2);
        nth(d - 2) = x;
    }

private:
    std::vector<T> stack_;
    std::vector<T> tmp_;
    size_t gap_;
	   
};

template <class _Value, class _SemanticAction,
          unsigned int _StackSize = 0>
class Parser {
public:
    typedef Token token_type;
    typedef _Value value_type;

    enum Nonterminal {
        Nonterminal_Expr,
        Nonterminal_Expr_seq0,
        Nonterminal_List,
        Nonterminal_Statement,
        Nonterminal_Statement_seq0,
        Nonterminal_Term,
        Nonterminal_Unit,
    };

public:
    Parser(_SemanticAction& sa) : sa_(sa) { reset(); }

    void reset() {
        error_ = false;
        accepted_ = false;
        clear_stack();
        rollback_tmp_stack();
        if (push_stack(0, value_type())) {
            commit_tmp_stack();
        } else {
            sa_.stack_overflow();
            error_ = true;
        }
    }

    bool post(token_type token, const value_type& value) {
        rollback_tmp_stack();
        error_ = false;
        while ((this->*(stack_top()->entry->state))(token, value))
            ; // may throw
        if (!error_) {
            commit_tmp_stack();
        } else {
            recover(token, value);
        }
        return accepted_ || error_;
    }

    bool accept(value_type& v) {
        assert(accepted_);
        if (error_) { return false; }
        v = accepted_value_;
        return true;
    }

    bool error() { return error_; }

private:
    typedef Parser<_Value, _SemanticAction, _StackSize> self_type;

    typedef bool (self_type::*state_type)(token_type, const value_type&);
    typedef int (self_type::*gotof_type)(Nonterminal);

    bool            accepted_;
    bool            error_;
    value_type      accepted_value_;
    _SemanticAction& sa_;

    struct table_entry {
        state_type  state;
        gotof_type  gotof;
        bool        handle_error;
    };

    struct stack_frame {
        const table_entry*  entry;
        value_type          value;
        int                 sequence_length;

        stack_frame(const table_entry* e, const value_type& v, int sl)
            : entry(e), value(v), sequence_length(sl) {}
    };

    Stack<stack_frame, _StackSize> stack_;

    bool push_stack(int state_index, const value_type& v, int sl = 0) {
        bool f = stack_.push(stack_frame(entry(state_index), v, sl));
        assert(!error_);
        if (!f) { 
            error_ = true;
            sa_.stack_overflow();
        }
        return f;
    }

    void pop_stack(size_t n) {
        int nn = int(n);
        while(nn--) {
            stack_.pop(1 + stack_.top().sequence_length);
        }
    }

    stack_frame* stack_top() {
        return &stack_.top();
    }

    const value_type& get_arg(size_t base, size_t index) {
        return stack_.get_arg(base, index).value;
    }

    void clear_stack() {
        stack_.clear();
    }

    void rollback_tmp_stack() {
        stack_.rollback_tmp();
    }

    void commit_tmp_stack() {
        stack_.commit_tmp();
    }

    void recover(token_type token, const value_type& value) {
        rollback_tmp_stack();
        error_ = false;
        while(!stack_top()->entry->handle_error) {
            pop_stack(1);
            if (stack_.empty()) {
                error_ = true;
                return;
            }
        }
        // post error_token;
        while ((this->*(stack_top()->entry->state))(token_error, value_type()));
        commit_tmp_stack();
        // repost original token
        // if it still causes error, discard it;
        while ((this->*(stack_top()->entry->state))(token, value));
        if (!error_) {
            commit_tmp_stack();
        }
        if (token != token_eof) {
            error_ = false;
        }
    }

    // EBNF support class
    struct Range {
        int beg;
        int end;
        Range() : beg(-1), end(-1) {}
        Range(int b, int e) : beg(b), end(e) {}
    };

    template <class T>
    class Optional {
    public:
        typedef Stack<stack_frame, _StackSize> stack_type;

    public:
        Optional(_SemanticAction& sa, stack_type& s, const Range& r)
            : sa_(&sa), s_(&s), p_(r.beg == r.end ? -1 : r.beg){}

        operator bool() const {
            return 0 <= p_;
        }
        bool operator!() const {
            return !bool(*this);
        }
        T operator*() const {
            T v;
            sa_->downcast(v, s_->nth(p_).value);
            return v;
        }

    private:
        _SemanticAction* sa_;
        stack_type*     s_;
        int             p_;

    };

    template <class T>
    class Sequence {
    public:
        typedef Stack<stack_frame, _StackSize> stack_type;

        class const_iterator {
        public:
            typedef T                       value_type;
            typedef std::input_iterator_tag iterator_category;
            typedef value_type              reference;
            typedef value_type*             pointer;
            typedef size_t                  difference_type;

        public:
            const_iterator(_SemanticAction& sa, stack_type& s, int p)
                : sa_(&sa), s_(&s), p_(p){}
            const_iterator(const const_iterator& x) : s_(x.s_), p_(x.p_){}
            const_iterator& operator=(const const_iterator& x) {
                sa_ = x.sa_;
                s_ = x.s_;
                p_ = x.p_;
                return *this;
            }
            value_type operator*() const {
                value_type v;
                sa_->downcast(v, s_->nth(p_).value);
                return v;
            }
            const_iterator& operator++() {
                ++p_;
                return *this;
            }
            bool operator==(const const_iterator& x) const {
                return p_ == x.p_;
            }
            bool operator!=(const const_iterator& x) const {
                return !((*this)==x);
            }
        private:
            _SemanticAction* sa_;
            stack_type*     s_;
            int             p_;

        };

    public:
        Sequence(_SemanticAction& sa, stack_type& stack, const Range& r)
            : sa_(sa), stack_(stack), range_(r) {
        }

        const_iterator begin() const {
            return const_iterator(sa_, stack_, range_.beg);
        }
        const_iterator end() const {
            return const_iterator(sa_, stack_, range_.end);
        }

    private:
        _SemanticAction& sa_;
        stack_type&     stack_;
        Range           range_;

    };

    // EBNF support member functions
    bool seq_head(Nonterminal nonterminal, int base) {
        // case '*': base == 0
        // case '+': base == 1
        int dest = (this->*(stack_nth_top(base)->entry->gotof))(nonterminal);
        return push_stack(dest, value_type(), base);
    }

    bool seq_trail(Nonterminal, int base) {
        // '*', '+' trailer
        assert(base == 2);
        stack_.swap_top_and_second();
        stack_top()->sequence_length++;
        return true;
    }

    bool seq_trail2(Nonterminal, int base) {
        // '/' trailer
        assert(base == 3);
        stack_.swap_top_and_second();
        pop_stack(1); // erase delimiter
        stack_.swap_top_and_second();
        stack_top()->sequence_length++;
        return true;
    }

    bool opt_nothing(Nonterminal nonterminal, int base) {
        // same as head of '*'
        assert(base == 0);
        return seq_head(nonterminal, base);
    }

    bool opt_just(Nonterminal nonterminal, int base) {
        // same as head of '+'
        assert(base == 1);
        return seq_head(nonterminal, base);
    }

    Range seq_get_range(size_t base, size_t index) {
        // returns beg = end if length = 0 (includes scalar value)
        // distinguishing 0-length-vector against scalar value is
        // caller's responsibility
        int n = int(base - index);
        assert(0 < n);
        int prev_actual_index;
        int actual_index  = stack_.depth();
        while(n--) {
            actual_index--;
            prev_actual_index = actual_index;
            actual_index -= stack_.nth(actual_index).sequence_length;
        }
        return Range(actual_index, prev_actual_index);
    }

    const value_type& seq_get_arg(size_t base, size_t index) {
        Range r = seq_get_range(base, index);
        // multiple value appearing here is not supported now
        assert(r.end - r.beg == 0); 
        return stack_.nth(r.beg).value;
    }

    stack_frame* stack_nth_top(int n) {
        Range r = seq_get_range(n + 1, 0);
        // multiple value appearing here is not supported now
        assert(r.end - r.beg == 0);
        return &stack_.nth(r.beg);
    }
    bool call_nothing(Nonterminal nonterminal, int base) {
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, value_type());
    }

    bool call_0_MakeAdd(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.MakeAdd(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_MakeSub(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.MakeSub(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_Identity(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.Identity(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_BlockStatement(Nonterminal nonterminal, int base, int arg_index0) {
        Sequence<shared_ptr<Ast>> arg0(sa_, stack_, seq_get_range(base, arg_index0)); 
        shared_ptr<Ast> r = sa_.BlockStatement(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_AssignStatement(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<String> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.AssignStatement(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_BreakStatement(Nonterminal nonterminal, int base) {
        shared_ptr<Ast> r = sa_.BreakStatement();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_ContinueStatement(Nonterminal nonterminal, int base) {
        shared_ptr<Ast> r = sa_.ContinueStatement();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_ElseStatement(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.ElseStatement(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_IfStatement(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.IfStatement(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_ReturnStatement(Nonterminal nonterminal, int base) {
        shared_ptr<Ast> r = sa_.ReturnStatement();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_1_ReturnStatement(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.ReturnStatement(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_WhileStatement(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.WhileStatement(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_EmptyStatement(Nonterminal nonterminal, int base) {
        shared_ptr<Ast> r = sa_.EmptyStatement();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_ExprStatement(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.ExprStatement(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_EmptyList(Nonterminal nonterminal, int base) {
        shared_ptr<Ast> r = sa_.EmptyList();
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_MakeList(Nonterminal nonterminal, int base, int arg_index0) {
        Sequence<shared_ptr<Ast>> arg0(sa_, stack_, seq_get_range(base, arg_index0)); 
        shared_ptr<Ast> r = sa_.MakeList(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_MakeDiv(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.MakeDiv(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_MakeMul(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.MakeMul(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_Variable(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<String> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.Variable(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_MakeCall(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {
        shared_ptr<String> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> arg1; sa_.downcast(arg1, get_arg(base, arg_index1));
        shared_ptr<Ast> r = sa_.MakeCall(arg0, arg1);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_1_Identity(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<EvalValue> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.Identity(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool call_0_Negate(Nonterminal nonterminal, int base, int arg_index0) {
        shared_ptr<Ast> arg0; sa_.downcast(arg0, get_arg(base, arg_index0));
        shared_ptr<Ast> r = sa_.Negate(arg0);
        value_type v; sa_.upcast(v, r);
        pop_stack(base);
        int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);
        return push_stack(dest_index, v);
    }

    bool state_0(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_open:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_ident:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_kwd_break:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case token_kwd_continue:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        case token_kwd_else:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_kwd_if:
            // shift
            push_stack(/*state*/ 15, value);
            return false;
        case token_kwd_return:
            // shift
            push_stack(/*state*/ 28, value);
            return false;
        case token_kwd_while:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_0(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 7;
        case Nonterminal_Statement: return 1;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_1(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
            // accept
            accepted_ = true;
            accepted_value_ = get_arg(1, 0);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_1(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_2(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_close:
            // shift
            push_stack(/*state*/ 14, value);
            return false;
        case token_brace_open:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_ident:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_kwd_break:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case token_kwd_continue:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        case token_kwd_else:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_kwd_if:
            // shift
            push_stack(/*state*/ 15, value);
            return false;
        case token_kwd_return:
            // shift
            push_stack(/*state*/ 28, value);
            return false;
        case token_kwd_while:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_2(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 7;
        case Nonterminal_Statement: return 56;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_3(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_open:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_ident:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_kwd_break:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case token_kwd_continue:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        case token_kwd_else:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_kwd_if:
            // shift
            push_stack(/*state*/ 15, value);
            return false;
        case token_kwd_return:
            // shift
            push_stack(/*state*/ 28, value);
            return false;
        case token_kwd_while:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_3(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 7;
        case Nonterminal_Statement: return 18;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_4(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_open:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_ident:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_kwd_break:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case token_kwd_continue:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        case token_kwd_else:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_kwd_if:
            // shift
            push_stack(/*state*/ 15, value);
            return false;
        case token_kwd_return:
            // shift
            push_stack(/*state*/ 28, value);
            return false;
        case token_kwd_while:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_4(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 7;
        case Nonterminal_Statement: return 19;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_5(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_open:
            // shift
            push_stack(/*state*/ 13, value);
            return false;
        case token_ident:
            // shift
            push_stack(/*state*/ 9, value);
            return false;
        case token_kwd_break:
            // shift
            push_stack(/*state*/ 26, value);
            return false;
        case token_kwd_continue:
            // shift
            push_stack(/*state*/ 24, value);
            return false;
        case token_kwd_else:
            // shift
            push_stack(/*state*/ 4, value);
            return false;
        case token_kwd_if:
            // shift
            push_stack(/*state*/ 15, value);
            return false;
        case token_kwd_return:
            // shift
            push_stack(/*state*/ 28, value);
            return false;
        case token_kwd_while:
            // shift
            push_stack(/*state*/ 20, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 6, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_5(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 7;
        case Nonterminal_Statement: return 23;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_6(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_EmptyStatement(Nonterminal_Statement, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_6(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_7(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 8, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_7(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_8(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_ExprStatement(Nonterminal_Statement, /*pop*/ 2, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_8(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_9(token_type token, const value_type& value) {
        switch(token) {
        case token_op_assign:
            // shift
            push_stack(/*state*/ 10, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 32, value);
            return false;
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_semicolon:
            // reduce
            return call_0_Variable(Nonterminal_Unit, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_9(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_10(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_10(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 11;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_11(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 12, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_11(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_12(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_AssignStatement(Nonterminal_Statement, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_12(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_13(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_close:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_brace_open:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_ident:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_break:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_continue:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_else:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_if:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_return:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_kwd_while:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_number:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_op_sub:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_paren_open:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        case token_semicolon:
            // reduce
            return seq_head(Nonterminal_Statement_seq0, /*pop*/ 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_13(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Statement_seq0: return 2;
        default: assert(0); return false;
        }
    }

    bool state_14(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_BlockStatement(Nonterminal_Statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_14(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_15(token_type token, const value_type& value) {
        switch(token) {
        case token_paren_open:
            // shift
            push_stack(/*state*/ 16, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_15(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_16(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_16(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 17;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_17(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_paren_close:
            // shift
            push_stack(/*state*/ 3, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_17(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_18(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_IfStatement(Nonterminal_Statement, /*pop*/ 5, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_18(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_19(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_ElseStatement(Nonterminal_Statement, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_19(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_20(token_type token, const value_type& value) {
        switch(token) {
        case token_paren_open:
            // shift
            push_stack(/*state*/ 21, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_20(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_21(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_21(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 22;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_22(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_paren_close:
            // shift
            push_stack(/*state*/ 5, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_22(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_23(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_WhileStatement(Nonterminal_Statement, /*pop*/ 5, 2, 4);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_23(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_24(token_type token, const value_type& value) {
        switch(token) {
        case token_semicolon:
            // shift
            push_stack(/*state*/ 25, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_24(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_25(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_ContinueStatement(Nonterminal_Statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_25(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_26(token_type token, const value_type& value) {
        switch(token) {
        case token_semicolon:
            // shift
            push_stack(/*state*/ 27, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_26(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_27(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_BreakStatement(Nonterminal_Statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_27(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_28(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 29, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_28(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 30;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_29(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_0_ReturnStatement(Nonterminal_Statement, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_29(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_30(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_semicolon:
            // shift
            push_stack(/*state*/ 31, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_30(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_31(token_type token, const value_type& value) {
        switch(token) {
        case token_eof:
        case token_brace_close:
        case token_brace_open:
        case token_ident:
        case token_kwd_break:
        case token_kwd_continue:
        case token_kwd_else:
        case token_kwd_if:
        case token_kwd_return:
        case token_kwd_while:
        case token_number:
        case token_op_sub:
        case token_paren_open:
        case token_semicolon:
            // reduce
            return call_1_ReturnStatement(Nonterminal_Statement, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_31(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_32(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        case token_paren_close:
            // reduce
            return call_0_EmptyList(Nonterminal_List, /*pop*/ 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_32(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 37;
        case Nonterminal_List: return 52;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        case Nonterminal_Expr_seq0: return 55;
        default: assert(0); return false;
        }
    }

    bool state_33(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_33(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 36;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_34(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_34(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Expr: return 38;
        case Nonterminal_Term: return 35;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_35(token_type token, const value_type& value) {
        switch(token) {
        case token_op_div:
            // shift
            push_stack(/*state*/ 46, value);
            return false;
        case token_op_mul:
            // shift
            push_stack(/*state*/ 44, value);
            return false;
        case token_comma:
        case token_op_add:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_Identity(Nonterminal_Expr, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_35(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_36(token_type token, const value_type& value) {
        switch(token) {
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_paren_close:
            // shift
            push_stack(/*state*/ 54, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_36(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_37(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
            // reduce
            return seq_head(Nonterminal_Expr_seq0, /*pop*/ 1);
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_paren_close:
            // reduce
            return seq_head(Nonterminal_Expr_seq0, /*pop*/ 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_37(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_38(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
            // reduce
            return seq_trail2(Nonterminal_Expr_seq0, /*pop*/ 3);
        case token_op_add:
            // shift
            push_stack(/*state*/ 39, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 41, value);
            return false;
        case token_paren_close:
            // reduce
            return seq_trail2(Nonterminal_Expr_seq0, /*pop*/ 3);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_38(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_39(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_39(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Term: return 40;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_40(token_type token, const value_type& value) {
        switch(token) {
        case token_op_div:
            // shift
            push_stack(/*state*/ 46, value);
            return false;
        case token_op_mul:
            // shift
            push_stack(/*state*/ 44, value);
            return false;
        case token_comma:
        case token_op_add:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_MakeAdd(Nonterminal_Expr, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_40(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_41(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_41(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Term: return 42;
        case Nonterminal_Unit: return 43;
        default: assert(0); return false;
        }
    }

    bool state_42(token_type token, const value_type& value) {
        switch(token) {
        case token_op_div:
            // shift
            push_stack(/*state*/ 46, value);
            return false;
        case token_op_mul:
            // shift
            push_stack(/*state*/ 44, value);
            return false;
        case token_comma:
        case token_op_add:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_MakeSub(Nonterminal_Expr, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_42(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_43(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_Identity(Nonterminal_Term, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_43(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_44(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_44(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Unit: return 45;
        default: assert(0); return false;
        }
    }

    bool state_45(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_MakeMul(Nonterminal_Term, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_45(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_46(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_46(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Unit: return 47;
        default: assert(0); return false;
        }
    }

    bool state_47(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_MakeDiv(Nonterminal_Term, /*pop*/ 3, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_47(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_48(token_type token, const value_type& value) {
        switch(token) {
        case token_ident:
            // shift
            push_stack(/*state*/ 51, value);
            return false;
        case token_number:
            // shift
            push_stack(/*state*/ 49, value);
            return false;
        case token_op_sub:
            // shift
            push_stack(/*state*/ 48, value);
            return false;
        case token_paren_open:
            // shift
            push_stack(/*state*/ 33, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_48(Nonterminal nonterminal) {
        switch(nonterminal) {
        case Nonterminal_Unit: return 50;
        default: assert(0); return false;
        }
    }

    bool state_49(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_1_Identity(Nonterminal_Unit, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_49(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_50(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_Negate(Nonterminal_Unit, /*pop*/ 2, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_50(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_51(token_type token, const value_type& value) {
        switch(token) {
        case token_paren_open:
            // shift
            push_stack(/*state*/ 32, value);
            return false;
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_Variable(Nonterminal_Unit, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_51(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_52(token_type token, const value_type& value) {
        switch(token) {
        case token_paren_close:
            // shift
            push_stack(/*state*/ 53, value);
            return false;
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_52(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_53(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_MakeCall(Nonterminal_Unit, /*pop*/ 4, 0, 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_53(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_54(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
        case token_op_add:
        case token_op_div:
        case token_op_mul:
        case token_op_sub:
        case token_paren_close:
        case token_semicolon:
            // reduce
            return call_0_Identity(Nonterminal_Unit, /*pop*/ 3, 1);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_54(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_55(token_type token, const value_type& value) {
        switch(token) {
        case token_comma:
            // shift
            push_stack(/*state*/ 34, value);
            return false;
        case token_paren_close:
            // reduce
            return call_0_MakeList(Nonterminal_List, /*pop*/ 1, 0);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_55(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    bool state_56(token_type token, const value_type& value) {
        switch(token) {
        case token_brace_close:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_brace_open:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_ident:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_break:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_continue:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_else:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_if:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_return:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_kwd_while:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_number:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_op_sub:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_paren_open:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        case token_semicolon:
            // reduce
            return seq_trail(Nonterminal_Statement_seq0, /*pop*/ 2);
        default:
            sa_.syntax_error();
            error_ = true;
            return false;
        }
    }

    int gotof_56(Nonterminal nonterminal) {
        assert(0);
        return true;
    }

    const table_entry* entry(int n) const {
        static const table_entry entries[] = {
            { &Parser::state_0, &Parser::gotof_0, false },
            { &Parser::state_1, &Parser::gotof_1, false },
            { &Parser::state_2, &Parser::gotof_2, false },
            { &Parser::state_3, &Parser::gotof_3, false },
            { &Parser::state_4, &Parser::gotof_4, false },
            { &Parser::state_5, &Parser::gotof_5, false },
            { &Parser::state_6, &Parser::gotof_6, false },
            { &Parser::state_7, &Parser::gotof_7, false },
            { &Parser::state_8, &Parser::gotof_8, false },
            { &Parser::state_9, &Parser::gotof_9, false },
            { &Parser::state_10, &Parser::gotof_10, false },
            { &Parser::state_11, &Parser::gotof_11, false },
            { &Parser::state_12, &Parser::gotof_12, false },
            { &Parser::state_13, &Parser::gotof_13, false },
            { &Parser::state_14, &Parser::gotof_14, false },
            { &Parser::state_15, &Parser::gotof_15, false },
            { &Parser::state_16, &Parser::gotof_16, false },
            { &Parser::state_17, &Parser::gotof_17, false },
            { &Parser::state_18, &Parser::gotof_18, false },
            { &Parser::state_19, &Parser::gotof_19, false },
            { &Parser::state_20, &Parser::gotof_20, false },
            { &Parser::state_21, &Parser::gotof_21, false },
            { &Parser::state_22, &Parser::gotof_22, false },
            { &Parser::state_23, &Parser::gotof_23, false },
            { &Parser::state_24, &Parser::gotof_24, false },
            { &Parser::state_25, &Parser::gotof_25, false },
            { &Parser::state_26, &Parser::gotof_26, false },
            { &Parser::state_27, &Parser::gotof_27, false },
            { &Parser::state_28, &Parser::gotof_28, false },
            { &Parser::state_29, &Parser::gotof_29, false },
            { &Parser::state_30, &Parser::gotof_30, false },
            { &Parser::state_31, &Parser::gotof_31, false },
            { &Parser::state_32, &Parser::gotof_32, false },
            { &Parser::state_33, &Parser::gotof_33, false },
            { &Parser::state_34, &Parser::gotof_34, false },
            { &Parser::state_35, &Parser::gotof_35, false },
            { &Parser::state_36, &Parser::gotof_36, false },
            { &Parser::state_37, &Parser::gotof_37, false },
            { &Parser::state_38, &Parser::gotof_38, false },
            { &Parser::state_39, &Parser::gotof_39, false },
            { &Parser::state_40, &Parser::gotof_40, false },
            { &Parser::state_41, &Parser::gotof_41, false },
            { &Parser::state_42, &Parser::gotof_42, false },
            { &Parser::state_43, &Parser::gotof_43, false },
            { &Parser::state_44, &Parser::gotof_44, false },
            { &Parser::state_45, &Parser::gotof_45, false },
            { &Parser::state_46, &Parser::gotof_46, false },
            { &Parser::state_47, &Parser::gotof_47, false },
            { &Parser::state_48, &Parser::gotof_48, false },
            { &Parser::state_49, &Parser::gotof_49, false },
            { &Parser::state_50, &Parser::gotof_50, false },
            { &Parser::state_51, &Parser::gotof_51, false },
            { &Parser::state_52, &Parser::gotof_52, false },
            { &Parser::state_53, &Parser::gotof_53, false },
            { &Parser::state_54, &Parser::gotof_54, false },
            { &Parser::state_55, &Parser::gotof_55, false },
            { &Parser::state_56, &Parser::gotof_56, false },
        };
        return &entries[n];
    }

};

} // namespace Scrip

#endif // #ifndef SCRIPPARSER_H_

