
// カンマ演算子
// リストを作る
p = 100, 200;

// リストはインデックスで参照する
// lget/lset命令
print(p[0]); // 100
print(p[1]); // 200
print(p[-1]); // 200 (p[2-1])
print(p[-2]); // 100 (p[2-2])

// リストでない普通の変数は要素1個のリストと同じ振る舞いをする
v = 24;
print(v); // 24
print(v[0]); // 24

// リストとリストをカンマ演算子で連結
// 演算時点で完全なコピーが作られる
// (スタック上の並びが保証されるようにするため)
q = p, 150, 250, v;

// q : [5] 100, 200, 150, 250, 24 

// 先頭4要素にはプロパティ形式でアクセスできる別名がある
assert(q[0] == q.x && q[0] == q.r);
assert(q[1] == q.y && q[1] == q.g);
assert(q[2] == q.z && q[2] == q.b);
assert(q[3] == q.w && q[3] == q.a);

// スライス
// 演算時点ではコピーは発生しないが
// 代入や引数渡しをするとコピーが作成される
r = 3,6,9,12;
r[0..2]; // [2] 3, 6
r[2..4]; // [2] 9, 12
r[-r.x..]; // [3] 6, 9, 12 : 末尾省略で最終要素まで
r[1..-1]; // [2] 6, 9
r[-1..1]; // [0] : 空のスライス。

// 関数の定義

// 仮引数が指定されている場合はそれぞれに値が割り当てられる
// 仮引数より多い引数が渡されてきた場合切り捨てられる
// returnば複数記述可能だがすべての戻り値で
// リスト個数が同じでなければならない
fn clamp(n, min, max) {
	if (n < min) return min;
	if (n > max) return max;
	return n;
}

print(clamp(50, 0, 100)); // 50
print(clamp(150, 0, 100, 125)); // 50 : 第4引数は無視される
//print(clamp(50, 0)); // エラー: 引数が不足している
print(clamp(q)); // 200 : qの先頭3要素が採用される

// リストを受ける
fn getLength(a[2], b[2]) {
	dx = a.x - b.x;
	dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}

print(getLength((10,10), (40,50))); // 50
print(getLength(10, 10, 40, 50)); // 50
print(getLength(10, (10, 40), 50)); // 50 : 引数はリスト扱いなので仮引数と形式が一致している必要はない

// 可変長引数には今のところ対応しない。
// 理由：スタックアクセス時のインデックス指定が上手く処理できない可能性があるため
// 方法が分かったら挑戦してみる？

// ビルトイン命令を関数として呼ぶ案
// @ + 命令名 + <属性>
// スタック整合性を取るのが難しいので使わない方が良い
//@adds<5>(q); 
